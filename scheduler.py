# ------------------ Summary ------------------
#     Thread #1: Reads the msg from edevice and puts them into a sorted Queue.
#     Thread #2: Picks the sorted msg, and calculates the Turn Around Time,
#                Then the thread sleeps until Thread #1 Puts a msg in the Queue
#                then it prints(deviceID:Turn-Around-Time)

# from base64 import decode
# from concurrent.futures import thread
# from platform import release
import sys
import socket
import time
from threading import Lock
from threading import Thread
# from collections import deque
# from urllib import request


# Default server port
server_port = 1337

# Buffer Size for allocating the socket's buffer size for receiving data
bufferSize = 512

# Prepare the mutex
mutexLock = Lock()
# Prepare the server as a UDP socket
serverUDP = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Received Data List (from Client)
RecList = []
# For keeping track of job compute time
timeTable = []
# The final result for device's total compute time shall be placed here
iJCT = []
devID = []
# ---- Hard Coded Section ----
# Does a maximum of three edevices
maxDev = 3
# May change from eDev's request amount
threadCount = 3
reqPerThreads = 3

# modDev is used to correctly count each device's consumed time
# This is the 'Nth' message before stopping, at the moment, 27 msgs before stopping.
# If this is changed, make sure edevice's also does.
modDev = maxDev * threadCount

totalJobs = maxDev * threadCount * reqPerThreads
# Subject to change if we've edevice's request 
# on how many threads to prepare to handle the requests from client.
# ----                   -----

#     Thread #1 is our Producer to the Scheduler / Queue (our Sorting fn() )
#     takes the ID and Job-Compute-Time into a sorted Queue.
#     1) Listens to the msgs generated by the Embedded Device(s)
#     2) Sorts the job into a Queue using an Shortest Job First Algorithms ( Sorts by job compute time < JCT + 1)


# The Producer 
class Producer(Thread):

    # Initiates given a specified server port from command line
    # As specified in the instructions
    def __init__(self, server_port):
        self.server_port = server_port
        Thread.__init__(self)


    def run(self):
    
        # Instructions indicate for hardcoded localhost as address
        # for the scheduler and command line arg for the port
        server_addr = ('localhost', self.server_port)
        serverUDP.bind(server_addr)

        # We'll be keeping track of how many different device's
        # we're getting requests from
        differentDev = 1
        devCount = []

        # 0 to device count if it reaches the cap, then finish loop
        # while (differentDev < maxDev-1):

        # 0 to thread amount
        for k in range(totalJobs):

            # get the lock for synchronizing the threads, if we've multiples
            mutexLock.acquire()

            # Extract the data (devID and JCT) from request
            # and the address
            data, addr = serverUDP.recvfrom(bufferSize)
            decodeData = data.decode()

            # Getting the device's ID
            devCount.append( (data.decode()).split(':')[0] )


            # Appends to the lists and sends a message to the client
            # confirming request received, for bonus in the instructions.
            # Note the serverUDP.sendto
            if data:
                RecList.append( decodeData ) 
                iJCT.append( data.decode() )
                serverUDP.sendto(data, addr)

                # Adds if we've a new / different device
                # if ( data.decode()).split(':')[0] in devCount:
                #     differentDev += 1 

            mutexLock.release()

        # Sorts the list of Received Data
        RecList.sort()
        # print(f"All Devices: {devCount}")

        # mutexLock.release()
        time.sleep(1)

# Consumer Class
# Responsible for sorting jobs into a Queue 
# using an Shortest Job First Algorithms (Sorts by job compute time < JCT + 1)
class Consumer(Thread):

    def __init__(self, t_number):
        self.t_number = t_number
        Thread.__init__(self)


    def run(self):

        # Keeps thread sleeping if 
        # we've not an item in the list to work with
        while len(RecList) < 1:
            time.sleep(1)

        # Locks for synchronizing threads
        mutexLock.acquire()

        # Index for acessing appending correct Time Table's data
        idx = 0
        # Will be used to sum the time 
        # for each device's Job Compute Time
        sumTime = 0

        # Will work for each amount of item in the list
        N = len(RecList)
        tempList = []

        for i in range(N):
            # If we've 3 devices, then for every 3rd iteration
            # we'll reset the sum time counter
            # As to not add the job compute time of other devices
            if  ( i % modDev ) == 0 :
                idx += 1
                sumTime = 0
        
            # Gets the Job Compute Time and adds the time to the counter
            # then appends to a temporary list
            getTime = RecList[i].split(':')[1]
            sumTime += int(getTime)
            tempList.append(sumTime)
            # Used for tracking / debugging :)
            # print(f"Time for: {idx}:{sumTime}")


        idx = 1
        # Every third item
        for i in range( len(tempList)):

            # Every modDev iteration
            # adds the sum to a time table
            if ( idx % modDev == 0):
                timeTable.append(tempList[i])
                devID.append( int( RecList[i].split(':')[0] ))

            idx += 1

        mutexLock.release()

        # Finally, prints the job for each data
        for i in range (len(timeTable)):
            print(f"Device {devID[i]} consumed {timeTable[i]} seconds of CPU time")

        # This is the list where we've sorted by Job Compute Time
        iJCT.sort( key = lambda x: x.split(':')[1] )

        # Print to Verify the Time Table Works :)
        print(f"\nTime Table Sorted by Shortest Job-Compute-Time \n{iJCT}")



# Takes one command line argument, port number.
def main():

    global server_port

    if len(sys.argv)-1 < 1:
        print("No specified port... Default is 1337")

    else:
        # Gets the server port from command line
        server_port = int( sys.argv[1] )


    # Starts the threads
    prodThread = Producer(server_port)
    prodThread.start()

    consThread = Consumer(1)
    consThread.start()

    # And synchronizes, although only two threads, 
    # one for each task
    # was specified...
    prodThread.join()
    consThread.join()



if __name__ == "__main__":
    main()
