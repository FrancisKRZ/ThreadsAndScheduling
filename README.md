--------------------------  --------------------------

            
            Project 1 -  Threads and Scheduling


-------------------------- Program Description: --------------------------


    This program simulates a distributed system
    consisting of embedded devices & a central server.

    The Central Server, scheduler.py receives jobs from the Client, edevice.py
    and computes the job's compute time, sorted in a Shortest Job First manner.


--------------------------                     --------------------------

-------------------------- How To Run --------------------------

One terminal running scheduler.py:
    python3 scheduler.py <port>

Three other terminals(s) / tab(s) running edevice.py:
    python3 edevice.py   localhost <port>
    python3 edevice.py 2 localhost <port>
    python3 edevice.py 3 localhost <port>
    

--------------------------           --------------------------



Embedded Device:

    1) Generates random numbers to simulate the device's job time for the compute server.
    2) Sends the msg (rand num) to the compute server, sleeps for a random number (1-5), before sending again.

    The msg will look like:     deviceID : job compute time
                                        3:5

Note: The bonus has been done and sleeps for the JCT after it confirms server received its data.

How it should run:
    edevice.py <server addr> <server port>

    * server addr is the Compute Server, server port is the Server's port number.
    * server port must be a big number lesser than 65,000

A second embedded device runs like:
    edevice.py 2 localhost 4017

--------------------------  --------------------------

The Compute Server:

    Consists of two threads

    Thread #1:
        Thread #1 is our Producer to the Scheduler / Queue (our Sorting fn() )
        takes the ID and Job-Compute-Time into a sorted Queue.

        1) Listens to the msgs generated by the Embedded Device(s)
        2) Sorts the job into a Queue using an Shortest Job First Algorithms ( Sorts by job compute time < JCT + 1)
    

    Thread #2:
        Thread #2 is our Consumer to the Queue
        Extracts the jobs from Queue and "execute them"  (i.e print() ?)
        
        1) Picks a msg from the Shared Queue
        2) Keeps a table with the sum of times spent in the Queue for each Device Job
        3) Sleep the time extracted from the msg picked from the Queue

        The Producer receives a msg  3:10
        The Producer puts 3:10 into the Shared Queue

        Then the Consumer picks the msg 3:10 from the Queue, 'add to the device 3 counter the time 10'
        and sleep for 10 seconds.

        The Scheduler stops after the Consumer reads the Nth (Variable N) time from the Queue,
        then prints the deviceID with the Time Consumed by its Job  (print deviceID:Turn Around Time)



How it should run:
    scheduler.py <server port>

    /****
    Example of the scheduler output for 3 embedded devices:
    Device 1 consumed 100 seconds of CPU time
    Device 2 consumed 132 seconds of CPU time
    Device 3 consumed 204 seconds of CPU time
    ****/


--------------------------  --------------------------



How to run the project:

    First run the scheduler.py on a separate tab with a specified port.
    example:

    python3 scheduler.py 1337

    Then run the edevices, note that the scheduler
    is expecting to receive three separate edevices.
    Each device sends up to 9 requests.
    For a total of 27 jobs the server will perform.

    python3 edevice.py localhost 1337

    To run another device,

    python3 edevice.py 2 localhost 1337
    
    and finally: python3 edevice 3 localhost 1337

    for a total of three devices sending requests to the server.



After the scheduler's Producer has finished its task,
you shall expect the result from the Consumer, thus finishing the program.


Expected output:

    Device 1 consumed 100 seconds of CPU time
    Device 2 consumed 132 seconds of CPU time
    Device 3 consumed 204 seconds of CPU time





References & Resources used:

    [Official-Reccomended]:
    https://docs.python.org/3/library/socket.html
    https://pymotw.com/3/threading/
    https://docs.python.org/3/library/threading.html


    [Other Resources]:
    https://superfastpython.com/thread-producer-consumer-pattern-in-python/
    

